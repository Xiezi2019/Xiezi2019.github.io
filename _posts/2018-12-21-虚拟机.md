---
layout:     post
title:      Java虚拟机
subtitle:   jvm运行时区域、垃圾回收
date:       2019-01-10
author:     Syuan
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - JVM
---

## 虚拟机

- JVM运行时区域
- JVM类加载机制
- 对象初始化
- JVM垃圾回收
- JVM调优

#### jvm运行时区域
线程私有
- 程序计数器
- 虚拟机栈
- 本地方法栈

非线程私有
- 方法区
- 堆

1. 程序计数器。
- 字节码的行号指示器，解释器通过程序计数器来依次读取指令
- 线程在上下文切换的时候，程序计数器保证线程切换回来的时候还能从上次停止的地方继续执行
- 生命周期：随着线程的创建而创建，死亡而死亡
2. 虚拟机栈
- 是方法运行的内存模型
- 在执行一个方法的时候，会创建一个栈帧，栈帧中包含有**局部变量表**，里面保存了方法的*局部变量*，*基本数据类型和对象引用。*

3. 本地方法栈
- 本地方法执行的区域
4. 方法区

   > 在1.8方法区被移除，元空间取而代之。使用的是直接内存，这样可以加载的类就受可用内存限制，可以加载的类更多了。
- 保存着被虚拟机加载的*类信息*

- 保存着静态变量、常量

- 运行时常量池，保存着字面量和符号引用，字面量相当于java中的常量，如文本字符串，final修饰的常量等

  > 1.7之后将运行时常量池从方法区移出来了，而是放在堆中了。
> **什么是类信息？**TODO
> 类型全限定名。
> 类型的直接超类的全限定名（除非这个类型是java.lang.Object，它没有超类）。
> 类型是类类型还是接口类型。
> 类型的访问修饰符（public、abstract或final的某个子集）。
> 任何直接超接口的全限定名的有序列表。
> 类型的常量池。
> 字段信息。
> 方法信息。
> 除了常量意外的所有类（静态）变量。
> 一个到类ClassLoader的引用。
> 一个到Class类的引用。
5. 堆
- 保存着实例对象
- 是内存最大的一个区域，也是GC主要针对的区域，因此也叫GC堆

#### 常量池



##### 运行时常量池

将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下**不同的类共用一个运行时常量池**，而且多个class文件中相同的常量池中的字符串会值保存一个。**通常所说的都是运行时常量池。**

运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。

##### 字符串常量池

```
String s0 = "hellow";
String s1 = new String("hellow");
```

第一种方式声明的字面量hellow是在编译期就已经确定的，它会直接进入class文件常量池中；当运行期间在字符串常量池中会保存它的一个引用。

class文件里常量池里大部分数据会被加载到“运行时常量池”，包括String的字面量；但同时“Hello”字符串的一个引用会被存到同样在“非堆”区域的“字符串常量池”中，而"Hello"本体还是和所有对象一样，创建在Java堆中。

当主线程开始创建s1时，虚拟机会先去字符串池中找是否有equals(“Hello”)的String，如果相等就把在字符串池中“Hello”的引用复制给s1；如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。

第二种方式方式使用了new String()，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。

**JDK1.7后，字符串常量池被移到了heap区，因此两者根本就不是一个概念。**

#### JVM类加载机制 

也就是一个.class文件是如何被JVM执行的过程

家宴准解除
加载/验证/准备/解析/初始化

##### 1.加载

- 获取：根据类的全限定名来获取定义该类的二进制字节流
- 存储：将二进制字节流按照虚拟机的要求存储在方法区
- 对象：在堆中生成一个class对象（保存在堆当中），作为方法区中的属性调用的接口
##### 2.验证

- 验证二进制字节码是否符合JVM的规范。如分母不为零、数组不能越界
- 为什么要进行检查？因为二进制字节码文件不一定是由Java语言编译过来的，又可能是其他语言编译过来的
- 因此分母为零、数组越界这些运行时异常是不可查异常，因为在编译期是无法检查出来，而要在类加载的验证阶段才能发现
##### 3.准备

- 为类变量分配内存，并初始化类变量，在方法区
> 注：这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、、false等），而不是被在Java代码中被显式地赋予的值。
##### 4.解析

- 将类当中的符号引用转换为直接引用
> 符号引用：用一组符号来代表所引用的对象，和虚拟机的内存结构无关。在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。 
>
> 直接引用：直接指向目标的指针、相对偏移量或者间接指向目标的句柄
> 直接引用是和虚拟机的内存结构无关的，同一个符号引用在不同虚拟机中的直接引用是不同的，如果有了直接引用那么所引用的目标一定已经存在于内存中了。
##### 5.初始化

- 执行类构造器<clinit>方法的过程
- <clinit>方法是由**静态变量的赋值动作**和**静态初始化块**语句合并产生的

##### 热加载

热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。

##### 类加载器与双亲委派模型

作用：通过类的全限定名获取该类二进制字节流

分类: 启动类加载器（虚拟机的一部分，用c++编写）、其他（扩展类加载器，应用程序类加载器）

**双亲委派模型**——该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

**好处**：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。	

**注意**：一个类要通过加载他的加载器和本身来确定其在虚拟机中的唯一性。

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。	

注意：一个类要通过加载他的加载器和本身来确定其在虚拟机中的唯一性。：一个类加载请求首先会给父类，只有父类无法完成时才尝试自己加载。

loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则调用父类加载的loadclass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。当父类加载器加载失败时抛出ClassNotFoundException，再尝试调用自己的findclass（）方法。

#### new一个对象的过程

1. 是否类加载
2. 分配内存

分配方式：
- 指针碰撞，针对内存规整，类似于秤可以左右移动的标尺
- 空闲列表，针对内存不规整，采用一个列表来记录内存的占用情况

内存分配的并发问题：
- CAS+失败重试
- TLAB(每个线程在eden区分配一块内存)

3. 内存初始化零值
- 确保对象的实例字段在Java代码中可以不赋初始值就可以直接使用，程序可以访问到该字段的数据类型锁对应的初始零值。

4. 设置对象头

> 对象的内存布局
> 1. 对象头：运行时数据：哈希吗、锁状态、线程持有的锁、偏向线程的ID；类型指针：通过该指针确定对象属于哪个类
> 2. 实例数据：真正存储的数据TODO
> 3. 对齐填充：TODO

5. 对象初始化
- 构造方法初始化

6. 将内存地址赋给栈内存中的引用变量

- 直接指针：栈中的reference中存的是实例的地址，速度快，节省了一次指针定位的开销。
- 句柄：reference中存的是句柄的地址，对象移动时地址不需要修改
#### JVM垃圾回收
##### 垃圾回收算法
- 标记-清除
- 复制：无碎片内存，而且高效
- 标记整理
- 分代回收——根据各个年代的特点采用适宜的回收算法

> 新生代分为三个区域，一个Eden区和两个Survivor区，它们之间的比例为（8：1：1），这个比例也是可以修改的。通常情况下，对象主要分配在新生代的Eden区上，少数情况下也可能会直接分配在老年代中。Java虚拟机每次使用新生代中的Eden和其中一块Survivor（From），在经过一次Minor GC后，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor空间上（这里使用的复制算法进行GC），最后清理掉Eden和刚才用过的Survivor（From）空间。将此时在Survivor空间存活下来的对象的年龄设置为1，以后这些对象每在Survivor区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。

##### 垃圾收集器

- 新生代收集器

  - Serial：复制、单线程、stw、没有切换效率高
  - ParNew：serial的多线程版本，有效利用cpu
  - parallel：和parnew相同，但并不追求低stw时间，而是追求高吞吐量

  > 运行用户代码时间/（运行用户代码时间+垃圾收集时间）

- 老年代收集器

  - Serial Old：标记整理算法，stw
  - CMS：标记清除、获取最短停顿时间、浮动垃圾以及cpu资源敏感垃圾碎片是它的缺点

  > - 初始标记，标记GC Roots 能够直接关联到达对象
  > - 并发标记，进行GC Roots Tracing 的过程
  > - 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录
  > - 并发清除，用标记清除算法清除对象。
  >
  > 其中**初始标记和重新标记**这两个步骤仍然需要"**stop the world**"。耗时最长的并发标记与并发清除过程收集器线程都可以与用户线程一起工作，总体上来说CMS收集器的内存回收过程是与用户线程一起并发执行的。

  - Parallel Old：多线程、“标记-整理”，可以充分利用多核CPU的计算能力

- 新生代和老年代收集器

  - G1

##### safepoint和saferegion

https://blog.csdn.net/ITer_ZC/article/details/41847887

##### 如何判断该不该回收
1. 引用计数器
2. 可达性分析

> GC Root都有哪些？
>
> 在方法区局部变量区的对象的引用：这些对象直接存储在栈帧的局部变量区中。
>
> 常量池中对象的引用：
>
> 本地方法中持有的对象的引用：
>
> 类的class对象：
>
> 无用的类：
>
> ·   该类所有实例都被回收（Java 堆中没有该类的对象）。
>
> ·   加载该类的 ClassLoader 已经被回收。
>
> ·   该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方利用反射访问该类。

##### 强、软、弱、虚引用

- 强引用：是最常见的引用，哪怕抛出OOM也不会回收
- 软引用：有用非必须，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
- 弱引用：垃圾收集器工作时，无论当前内存是否足够都会回收弱引用关联的对象
- 虚引用：虚引用主要用来跟踪对象被垃圾回收的活动，不能决定对象生命周期。

#### 内存溢出的排查

##### 1.栈溢出如何解决

把递归换为非递归，因为一般是出现死循环或者大量的递归调用导致栈溢出

使用static代替非静态的局部对象

增大栈的大小

##### 2.OOM如何排查以及如何排查内存泄漏todo

jdk/jconsole.exe  jdk/jvisualvm.exe 

#### JVM调优以及相关参数

**目标**

1. 减少移动到老年代的对象数量

减少了移动到老年代中对象的数量就可以减少Full GC发生的次数，我们知道Full GC的时间是大于minor GC的。
2. 缩短Full GC的执行时间
- 通过提高老年代的容量，可以减少Full GC的次数，但是会增加单次GC的时间
- 通过降低老年代的容量，可以减少单次GC时间，但是会增加Full GC发生的次数

**常用的一些参数**

- -Xms  启动JVM时初始堆大小
- -Xmx  堆空间的最大值
- -XX:NewRatio 新生代和老年代的比例
- -XX:NewSize  新生代大小
- -XX:PermSize  老年代大小
- -XX:SurvivorRatio Eden区和Survivor区的比例



```
#   jvm参数

- 标准参数（-）

  所有JVM实现都必须实现这些的功能，向后兼容。-verbose:class（输出jvm载入类的相关信息）；-verbose:gc(输出每次gc相关情况)；-verbose:jni(本地方法调用的相关情况)

- 非标准参数（-X） 主要用于jvm调优和Debug

  默认jvm实现这些参数的功能，不保证所有的都实现，不保证向后兼容；-Xms512m（jvm启动时初始大小）;-XMx521m(堆空间的最大值);-Xmn200m(新生代内存最大值)

- 非Stable参数（-XX)

  各个虚拟机实现有所不同 -XX:permSize=64M(老年代大小) -XX:MaxPermSzie=512m

##### jvm常用工具

- jps 查看java进程 

  jps -1 //查看完整类名

  jmap -heap pid >1.txt // 查看jvm内存配置，并将结果保存至txt文档 	

- jinfo 配置信息

  jinfo -flag initialHeapSize pid //查看初始堆内存

  jinfo -flag MaxHeapSize  pid //查看最大堆内存
```



重要引用：

https://blog.csdn.net/sinat_33087001/article/details/76977437

https://blog.csdn.net/qq_17639593/article/details/81007975