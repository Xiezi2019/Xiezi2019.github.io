MySQL优化

- 单表优化

   除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在`千万级`以下，字符串为主的表在`五百万`以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量 

- 字段

  - 尽量使用`TINYINT`、`SMALLINT`、`MEDIUM_INT`作为整数类型而非`INT`，如果非负则加上`UNSIGNED` 
  -  `VARCHAR`的长度只分配真正需要的空间 
  -  使用枚举或整数代替字符串类型 
  -  尽量使用`TIMESTAMP`而非`DATETIME` 
  -  单表不要有太多字段，建议在20以内 
  -  避免使用NULL字段，很难查询优化且占用额外索引空间 
  -  用整型来存IP 

- 索引

- -  索引并不是越多越好，要根据查询有针对性的创建，考虑在`WHERE`和`ORDER BY`命令上涉及的列建立索引，可根据`EXPLAIN`来查看是否用了索引还是全表扫描 
  -  应尽量避免在`WHERE`子句中对字段进行`NULL`值判断，否则将导致引擎放弃使用索引而进行全表扫描 
  -  值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段 
  -  字符字段只建前缀索引 
  -  字符字段最好不要做主键 
  -  不用外键，由程序保证约束 
  -  尽量不用`UNIQUE`，由程序保证约束 
  -  使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引 

- 查询SQL

- -  不用`SELECT *` 
  -  少用`JOIN` 
  -  尽量避免在`WHERE`子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描 
  -  可通过开启慢查询日志来找出较慢的SQL 
  -  sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库 

- 引擎

  - MyISAM (5.1前默认)

    -  不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁 
    -  不支持事务 
    -  不支持外键 
    -  不支持崩溃后的安全恢复 
    -  在表有读取查询的同时，支持往表中插入新纪录 
    -  支持`BLOB`和`TEXT`的前500个字符索引，支持全文索引 
    -  支持延迟更新索引，极大提升写入性能 
    -  对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用 

  - InnoDB（5.5后默认）

    -  支持行锁，采用MVCC来支持高并发 
    -  支持事务 
    -  支持外键 
    -  支持崩溃后的安全恢复 
    -  不支持全文索引
    - 总体来讲，MyISAM适合`SELECT`密集型的表，而InnoDB适合`INSERT`和`UPDATE`密集型的表- 

    

    ## 数据库分析优化
    
    - 慢查询日志
- Explain分析
    
[]: https://blog.csdn.net/qq_34495753/article/details/88338149?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159962111519724839234046%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159962111519724839234046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-88338149.pc_first_rank_v2_rank_v28&amp;utm_term=explain%E5%88%86%E6%9E%90&amp;spm=1018.2118.3001.4187
    
    
    
    ## 调优参数
    
    -  sysbench：一个模块化，跨平台以及多线程的性能测试工具 
    - iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具
- tpcc-mysql：Percona开发的TPC-C测试工具
    

    
-  back_log ： back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中
    -  wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。 可以从默认的8小时减到半小时  
-   max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限 
    -  thread_concurrency：并发线程数，设为CPU核数的两倍 
-  key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。 
    -  sort_buffer_size：MySql执行排序使用的缓存大小 。 如果想要增加`ORDER BY`的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小 
-  record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值 
    

    
-  升级硬件
    
        根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能 
    
    - 读写分离
    
   从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离 
    
- 缓存
    
      缓存可以发生的在这些层级

      - MySQL内部：在系统调优参数介绍了相关设置
  - 数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象`Persistence Object`
      - 应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象`Data Transfer Object`
  - Web层：针对web页面做缓存
      - 浏览器客户端：用户端的缓存

     服务层的缓存实现，目前主要有两种方式： 

    -  直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。 
-  回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。 
    
  
    
    - 表分区
    
      ​	
    
    
    
    ## (3)事务是如何通过日志来实现的，说得越深入越好
    
    基本流程如下：
    
    因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。
    
     
  
  

